Parser+Operators.swift
	public func >>- <T,A,B> (p: Parser<T,A>, f: A -> Parser<T,B>) -> Parser<T,B>
	public func <^> <T,A,B> (f: A -> B, p: Parser<T,A>) -> Parser<T,B>
	public func <*> <T,A,B> (fp: Parser<T,A->B>, p: Parser<T,A>) -> Parser<T,B>
	public func <* <T,A,B> (p1: Parser<T,A>, p2: Parser<T,B>) -> Parser<T,A>
	public func *> <T,A,B> (p1: Parser<T,A>, p2: Parser<T,B>) -> Parser<T,B>
	public func <|> <T,A> (l: Parser<T,A>, r: Parser<T,A>) -> Parser<T,A>
Result+Operators.swift
	public func <^> <T, U, E> (f: T -> U, a: Result<T, E>) -> Result<U, E>
	public func <*> <T, U, E> (f: Result<(T -> U), E>, a: Result<T, E>) -> Result<U, E>
ParserInput.swift
	public func == <T> (lhs: ParserInput<T>, rhs: ParserInput<T>) -> Bool
	public var debugDescription: String { return "position:\(position())" }
Parser.swift
	public struct ParserError : ErrorType
	public let _domain: String = "FootlessParser.ParserError"
	public let _code: Int = 1
	public let message: String
	public init (_ message: String)
	public struct ParserError : ErrorType
	public var description: String
	public func == (e1: ParserError, e2: ParserError) -> Bool
	public struct Parser <Token, Output>
	public let parse: ParserInput<Token> -> Result<(output: Output, nextinput: ParserInput<Token>), ParserError>
